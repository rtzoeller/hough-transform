#ifndef HOUGH_IMAGE_IO_H
#define HOUGH_IMAGE_IO_H

#include <armadillo>
#include <opencv2/opencv.hpp>
#include <memory>

/**
 * \file image_io.h Image manipulation and OpenCV <-> Armadillo conversions
 */

/**
 * \brief Load an image into an Armadillo matrix
 *
 * \param[in]   filename    The file to load
 */
template<typename T>
std::unique_ptr<arma::Mat<T>> open_image_grayscale(std::string filename) {
    // Armadillo stores matrices in column major order, OpenCV in row major order,
    // so we have to transpose the matrix before handing it to Armadillo.
    cv::Mat image = cv::imread(filename, CV_LOAD_IMAGE_GRAYSCALE);
    image = image.t();
    arma::Mat<uint8_t> output(image.ptr(), image.size().width, image.size().height);
    return std::make_unique<arma::Mat<T>>(arma::conv_to<arma::Mat<T>>::from(output));
}

/**
 * \brief Save an Armadillo matrix to a file in grayscale
 *
 * \param[in]   matrix      The matrix to save
 * \param[in]   filename    The file to save the matrix to
 */
template<typename T>
void save_image_grayscale(const arma::Mat<T> &matrix, std::string filename) {
    // Scale down to a 0-255 range
    arma::Mat<T> scaled(matrix);
    scaled *= 255;
    scaled /= matrix.max();
    arma::Mat<uint8_t> bytes = arma::conv_to<arma::Mat<uint8_t>>::from(scaled);
    bytes = bytes.t();
    cv::Mat image(bytes.n_cols, bytes.n_rows, CV_8UC1, bytes.memptr());
    cv::imwrite(filename, image);
}

#endif //HOUGH_IMAGE_IO_H
